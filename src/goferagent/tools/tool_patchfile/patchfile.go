package tool_patchfile

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/elee1766/gofer/src/agent"
	"github.com/elee1766/gofer/src/aisdk"
	"github.com/elee1766/gofer/src/goferagent/toolsutil"
	"github.com/elee1766/gofer/src/schema"
	jsonschema "github.com/swaggest/jsonschema-go"
)

// Tool name constant
const Name = "patch"

const patchPrompt = `Apply a patch to a file using the patch command.
This tool allows you to apply unified diff patches to files, useful for making precise changes to code.

Usage notes:
- The patch parameter should contain a valid unified diff
- The file_path is optional - if not provided, the patch should contain the file path in the diff header
- Use this for applying changes generated by diff tools or version control systems
- The patch format should follow standard unified diff format (with --- and +++ headers)`

// PatchTool returns the patch tool definition using GenericTool
func Tool() (agent.Tool, error) {
	return agent.NewGenericTool(
		Name,
		patchPrompt,
		patchHandler,
	)
}

// LegacyPatchTool returns the legacy patch tool definition for backward compatibility
func LegacyPatchTool() agent.Tool {
	return &agent.LegacyTool{
		Type: "function",
		Function: aisdk.ToolFunction{
			Name:        Name,
			Description: patchPrompt,
			Parameters: schema.CreateObjectSchema(map[string]*jsonschema.Schema{
				"patch": schema.CreateStringSchema("The patch content in unified diff format"),
				"file_path": schema.CreateStringSchema("The file path to apply the patch to (optional if patch contains file paths)"),
			}, []string{"patch"}),
		},
		Executor: patchExecutor,
	}
}

// PatchInput represents the parameters for patch
type PatchInput struct {
	Patch    string `json:"patch" jsonschema:"required,description=The patch content in unified diff format"`
	FilePath string `json:"file_path,omitempty" jsonschema:"description=The file path to apply the patch to (optional if patch contains file paths)"`
}

// PatchOutput represents the response from patch
type PatchOutput struct {
	Success  bool   `json:"success" jsonschema:"description=Whether the patch was applied successfully"`
	Message  string `json:"message" jsonschema:"description=Status message about the patch operation"`
	FilePath string `json:"file_path,omitempty" jsonschema:"description=The file path that was patched"`
	Output   string `json:"output,omitempty" jsonschema:"description=Output from the patch command"`
}

// patchHandler is the type-safe handler for the patch tool
func patchHandler(ctx context.Context, input PatchInput) (PatchOutput, error) {
	return executePatch(ctx, input.Patch, input.FilePath)
}

func patchExecutor(ctx context.Context, call *aisdk.ToolCall) (*aisdk.ToolResponse, error) {
	var params PatchInput
	if err := json.Unmarshal(call.Function.Arguments, &params); err != nil {
		return &aisdk.ToolResponse{
			Type:    "error",
			Content: []byte("Failed to parse parameters"),
			IsError: true,
		}, nil
	}

	// Use the shared implementation
	result, err := executePatch(ctx, params.Patch, params.FilePath)
	if err != nil {
		return &aisdk.ToolResponse{
			Type:    "error",
			Content: []byte(err.Error()),
			IsError: true,
		}, nil
	}

	resultJSON, _ := json.Marshal(result)
	return &aisdk.ToolResponse{
		Type:    "success",
		Content: resultJSON,
		IsError: false,
	}, nil
}

// executePatch contains the shared patch execution logic
func executePatch(ctx context.Context, patch, filePath string) (PatchOutput, error) {
	logger := toolsutil.GetLogger()
	
	// Validate patch
	if patch == "" {
		return PatchOutput{
			Success: false,
			Message: "Patch content is required",
		}, fmt.Errorf("patch content is required")
	}

	// Create a temporary file for the patch
	tmpFile, err := os.CreateTemp("", "patch-*.diff")
	if err != nil {
		return PatchOutput{
			Success: false,
			Message: "Failed to create temporary patch file",
		}, err
	}
	defer os.Remove(tmpFile.Name())

	// Write patch content to temporary file
	if _, err := tmpFile.Write([]byte(patch)); err != nil {
		tmpFile.Close()
		return PatchOutput{
			Success: false,
			Message: "Failed to write patch content",
		}, err
	}
	tmpFile.Close()

	// Prepare patch command
	args := []string{"-u", "-i", tmpFile.Name()}
	
	// If file path is provided, use it
	if filePath != "" {
		if !toolsutil.IsPathSafe(filePath) {
			return PatchOutput{
				Success: false,
				Message: "Path is not safe to access",
			}, fmt.Errorf("path is not safe to access")
		}
		args = append(args, filepath.Clean(filePath))
	}

	// Execute patch command
	cmd := exec.CommandContext(ctx, "patch", args...)
	output, err := cmd.CombinedOutput()

	response := PatchOutput{
		Output: string(output),
	}

	if err != nil {
		response.Success = false
		response.Message = fmt.Sprintf("Patch failed: %v", err)
		if strings.Contains(string(output), "FAILED") {
			response.Message += " - Some hunks failed to apply"
		}
		// For GenericTool, we don't return error if patch command fails
		// since the failure info is in the response
	} else {
		response.Success = true
		response.Message = "Patch applied successfully"
		if filePath != "" {
			response.FilePath = filePath
		}
	}

	logger.Info("Applied patch",
		"success", response.Success,
		"file_path", filePath,
		"patch_size", len(patch),
	)

	return response, nil
}